#!/usr/bin/env perl
use strict;
use warnings;

# Database imports
#
# Get DBD::SQLite to install all you need
#
use DBI qw(:sql_types);

=head1 NAME

zscan_createdb.pl - Perl script for creating a new SQLite database that
is properly structured for use with ZScan.

=head1 SYNOPSIS

  ./zscan_createdb.pl [dbpath]

=head1 DESCRIPTION

This creates two tables in the database, C<zset> and C<zscan>.

Each record in the C<zset> table represents a dataset.  Each client that
uses ZScan has its own unique dataset, so that it doesn't have to worry
about synchronization problems when multiple clients access the same
dataset.  Datasets in this SQL database are essentially just mirrors of
local client databases, with a unique mirror (dataset) for each specific
client database.

The C<zsetuid> is a unique ID for the dataset which the client uses to
connect to it.  It should be a string of one to 255 ASCII alphanumerics
and hyphens, and unique IDs are case sensitive.  The C<zsetpwh> is
either a special value C<?> or C<*> or C<!> or otherwise it contains a
hash generated by Crypt::Bcrypt.  The C<?> value indicates that no
client is currently connected to this dataset, and the dataset can be
claimed on a first-come first-serve basis.  The C<*> value indicates
that all passwords will be accepted and therefore any client can connect
without claiming; this is only intended to fix cases where you need to
allow a client to sync one last time before resetting it.  The C<!>
value indicates that the dataset can neither be claimed nor connected
to, which is useful for freezing datasets.

Each record in the C<zscan> table records a scanning event.  All such
records are linked to a specific dataset with a foreign key.  The
C<zscanseq> is the unique integer key of the record within a specific
dataset.  The C<zscanisbn> is a string of exactly 13 digits holding the
ISBN-13 that was scanned.  The C<zscantime> counts the number of
I<minutes> that have elapsed since the UNIX epoch to the time when the
scan was made.  Finally, the C<zscancflag> is zero for regular records,
or one for records that have been canceled (which allows for delete-like
functionality without actually deleting data).

See the SQL string embedded in this script for the complete database
structure.

=cut

# Define a string holding the whole SQL script for creating the
# structure of the database, with semicolons used as the termination
# character for each statement and nowhere else
#
my $sql_script = q{

CREATE TABLE zset(
  zsetid  INTEGER PRIMARY KEY ASC,
  zsetuid TEXT UNIQUE NOT NULL,
  zsetpwh TEXT NOT NULL
);

CREATE UNIQUE INDEX ix_zset_uid
  ON zset(zsetuid);

CREATE TABLE zscan(
  zscanid    INTEGER PRIMARY KEY ASC,
  zsetid     INTEGER NOT NULL
                REFERENCES zset(zsetid)
                  ON DELETE RESTRICT
                  ON UPDATE RESTRICT,
  zscanseq   INTEGER NOT NULL,
  zscanisbn  TEXT NOT NULL,
  zscantime  INTEGER NOT NULL,
  zscancflag INTEGER NOT NULL,
  UNIQUE     (zsetid, zscanseq)
);

CREATE UNIQUE INDEX ix_zscan_rec
  ON zscan(zsetid, zscanseq);

CREATE INDEX ix_zscan_isbn
  ON zscan(zscanisbn);

};

# ==================
# Program entrypoint
# ==================

# Make sure we got the right number of arguments and store to variables
#
($#ARGV == 0) or die "Wrong number of arguments, stopped";
my $dbpath = $ARGV[0];

# Fail if database file already exists
#
(not (-e $dbpath)) or
  die "Database file '$dbpath' already exists, stopped";

# Connect to the SQLite database; the database will be created if it
# does not exist; also, turn autocommit mode off so we can use
# transactions
#
my $dbh = DBI->connect("dbi:SQLite:dbname=$dbpath", "", "", {
                        AutoCommit => 0
                      }) or
  die "Can't connect to database '$dbpath', stopped";

# Wrap the rest of the program in an eval so that a rollback is issued
# if there is any error
#
eval {

  # Begin exclusive transaction
  $dbh->do('BEGIN EXCLUSIVE TRANSACTION');

  # Parse our SQL script into a sequence of statements, each ending with
  # a semicolon
  my @sql_list;
  @sql_list = $sql_script =~ m/(.*?);/gs
    or die "Failed to parse SQL script, stopped";
  
  # Run all the SQL statements needed to build the the database
  # structure
  for my $sql (@sql_list) {
    $dbh->do($sql) or
      die "SQL error: $dbh->errstr, stopped";
  }
  
  # If we got here, commit all our changes to the database
  $dbh->commit or
    die "Commit error: $dbh->errstr, stopped";

};
if ($@) {
  # An error happened, so rollback, disconnect from database, and raise
  # the error again
  $dbh->rollback;
  $dbh->disconnect;
  die $@;
}

# If we got here successfully, we can disconnect from the database
#
$dbh->disconnect;

=head1 AUTHOR

Noah Johnson, C<noah.johnson@loupmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 Multimedia Data Technology Inc.

MIT License:

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
